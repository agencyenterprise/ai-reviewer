# Cursor Rules for RAND AI Reviewer

## Project Overview

This is an AI-powered document review system with a Python backend (FastAPI + LangChain) and Next.js frontend. The system uses agent-based workflows to analyze documents for claims, citations, and references.

## Universal Code Quality Standards

### File Organization & Size
- **Target file size: ~100-200 lines** (current codebase averages 83-104 lines)
- **Maximum file size: 300 lines** (exceptions for configuration, migrations, complex workflows)
- **Principle over rules**: Prioritize logical cohesion and single responsibility over strict line counts
- Break large files into smaller, focused modules when they serve multiple purposes
- Use clear, descriptive file names that reflect their purpose
- Group related functionality in directories (agents/, workflows/, services/)

#### When to split files:
- Multiple classes/functions with different responsibilities
- Mixed concerns (business logic + configuration + utilities)
- Difficulty understanding the file's purpose at a glance
- Complex files that are hard to test in isolation

#### When larger files are acceptable:
- Database models with many fields (SQLModel classes)
- Configuration files with extensive settings
- Complex workflow definitions that need to stay together
- Single-purpose modules with high internal cohesion

### SOLID Principles
- **Single Responsibility**: Each class/function should have one reason to change
- **Open/Closed**: Use composition and dependency injection over inheritance
- **Liskov Substitution**: Ensure subtypes are substitutable for base types
- **Interface Segregation**: Create focused, role-based interfaces
- **Dependency Inversion**: Depend on abstractions, not concretions

### Code Style & Formatting
- Use consistent naming conventions throughout the project
- Write self-documenting code with clear variable and function names
- Add docstrings/comments for complex business logic only
- Remove unused imports and variables
- Keep functions focused and testable (max 20 lines preferred)

### File Size Monitoring
```bash
# Check current file size statistics
find lib api -name "*.py" -exec wc -l {} + | sort -n
find frontend -name "*.tsx" -o -name "*.ts" | grep -v node_modules | xargs wc -l | sort -n

# Identify files exceeding guidelines
find . -name "*.py" -exec sh -c 'wc -l < "$1" | grep -E "^[3-9][0-9][0-9]|^[2][5-9][0-9]" && echo "$1"' _ {} \;
```

## Python Backend Rules

### Technology Stack
- Python 3.13+ with `uv` for dependency management
- FastAPI for web framework with automatic OpenAPI docs
- SQLModel for database models (combines SQLAlchemy + Pydantic)
- LangChain/LangGraph for AI workflow orchestration
- PostgreSQL with Alembic for migrations
- Black for code formatting, pytest for testing

### Code Standards

#### Type Safety
```python
# Always use type hints
from typing import List, Optional, Union
from pydantic import BaseModel

def process_documents(files: List[File], config: Optional[ProcessingConfig] = None) -> DocumentResult:
    pass

# Use TypedDict for structured data (especially workflow state)
from typing import TypedDict
class WorkflowState(TypedDict, total=False):
    documents: List[Document]
    results: Optional[ProcessingResult]
```

#### Async/Await Patterns
```python
# Prefer async/await for I/O operations
async def process_with_llm(content: str) -> Result:
    llm_response = await llm.ainvoke(content)
    return Result(data=llm_response)

# Use asyncio.gather for parallel operations
results = await asyncio.gather(
    process_chunk_1(chunk1),
    process_chunk_2(chunk2)
)
```

#### Database & Models
```python
# Use SQLModel for database models
from sqlmodel import SQLModel, Field
import uuid

class Agent(SQLModel, table=True):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()), primary_key=True)
    name: str = Field(max_length=255, index=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)

# Separate database models from API models
class AgentResponse(BaseModel):
    id: str
    name: str
    # Only expose what's needed for API
```

#### Error Handling
```python
# Use specific exception types
class DocumentProcessingError(Exception):
    def __init__(self, message: str, document_id: str):
        self.document_id = document_id
        super().__init__(message)

# Handle errors at appropriate levels
try:
    result = await process_document(doc)
except DocumentProcessingError as e:
    logger.error(f"Failed to process document {e.document_id}: {e}")
    raise HTTPException(status_code=422, detail=str(e))
```

#### Agent & Workflow Patterns
```python
# Follow the established agent pattern
class DocumentProcessor:
    def __init__(self, embeddings: Embeddings, chunker: TextSplitter):
        self._embeddings = embeddings
        self._chunker = chunker
    
    async def process(self, document: Document) -> List[Chunk]:
        chunks = self._chunker.split_documents([document])
        return [Chunk(content=chunk.page_content) for chunk in chunks]

# Use composition for workflow nodes
def create_processing_node(processor: DocumentProcessor):
    async def process_node(state: WorkflowState) -> WorkflowState:
        processed = await processor.process(state["document"])
        return {**state, "chunks": processed}
    return process_node
```

#### Project Structure
```
lib/
├── agents/          # Individual AI agents (claim_detector, etc.)
├── workflows/       # LangGraph workflow definitions
├── services/        # Business logic services
├── models/          # Database models
└── config/          # Configuration modules

api/                 # FastAPI application
streamlit/          # Streamlit UI (legacy)
```

## Frontend Rules

### Technology Stack
- Next.js 15 with App Router and Turbopack
- React 19 with TypeScript (strict mode)
- Tailwind CSS for styling with shadcn/ui components
- pnpm for package management
- ESLint + Prettier for code quality

### Code Standards

#### TypeScript Best Practices
```tsx
// Use proper TypeScript interfaces
interface WizardState {
  currentStep: number;
  mainDocument: File | null;
  supportingDocuments: File[];
  isProcessing: boolean;
  analysisResults: AnalysisResult | null;
}

// Type component props explicitly
interface FileUploadProps {
  onUpload: (files: File[]) -> void;
  maxFiles?: number;
  accept?: string[];
}

// Use proper generic constraints
function useAsync<T>(
  asyncFunction: () => Promise<T>
): { data: T | null; loading: boolean; error: Error | null } {
  // Implementation
}
```

#### React Patterns
```tsx
// Use React 19 patterns - prefer function components
function DocumentViewer({ document }: { document: Document }) {
  const [isLoading, setIsLoading] = React.useState(false);
  
  // Custom hooks for complex logic
  const { analysis, error, refresh } = useDocumentAnalysis(document.id);
  
  if (error) return <ErrorDisplay error={error} />;
  if (isLoading) return <LoadingSpinner />;
  
  return <DocumentDisplay document={document} analysis={analysis} />;
}

// Use React Context for shared state
const WizardContext = React.createContext<WizardContextType | undefined>(undefined);

export function useWizard() {
  const context = React.useContext(WizardContext);
  if (!context) {
    throw new Error('useWizard must be used within WizardProvider');
  }
  return context;
}
```

#### State Management
```tsx
// Use useReducer for complex state logic
type WizardAction = 
  | { type: 'SET_STEP'; payload: number }
  | { type: 'SET_DOCUMENT'; payload: File | null }
  | { type: 'SET_PROCESSING'; payload: boolean };

function wizardReducer(state: WizardState, action: WizardAction): WizardState {
  switch (action.type) {
    case 'SET_STEP':
      return { ...state, currentStep: action.payload };
    // ... other cases
    default:
      return state;
  }
}

// Keep component state local when possible
function FileUpload({ onUpload }: FileUploadProps) {
  const [dragActive, setDragActive] = React.useState(false);
  // Don't lift state unnecessarily
}
```

#### Component Organization
```tsx
// Break down large components
function ResultsStep() {
  return (
    <div className="space-y-6">
      <SummaryCards results={results} />
      <TabNavigation tabs={tabs} />
      <TabContent activeTab={activeTab} />
    </div>
  );
}

// Co-locate related components
components/
├── wizard/
│   ├── upload-step/
│   │   ├── index.tsx
│   │   ├── file-list-item.tsx
│   │   └── upload-section.tsx
│   └── results-step/
│       ├── index.tsx
│       ├── components/
│       └── tabs/
```

#### API Integration
```tsx
// Create typed service layers
class AnalysisService {
  static async processDocument(
    file: File, 
    supportingFiles: File[]
  ): Promise<AnalysisResult> {
    const formData = new FormData();
    formData.append('document', file);
    supportingFiles.forEach(f => formData.append('supporting', f));
    
    const response = await fetch('/api/analyze', {
      method: 'POST',
      body: formData,
    });
    
    if (!response.ok) {
      throw new Error(`Analysis failed: ${response.statusText}`);
    }
    
    return response.json();
  }
}

// Use React Query or SWR for data fetching (when added)
function useAnalysis(documentId: string) {
  return React.useMemo(() => {
    // Implement data fetching logic
  }, [documentId]);
}
```

### UI/UX Guidelines
- Use shadcn/ui components for consistency
- Implement proper loading states and error boundaries
- Ensure accessibility (ARIA labels, keyboard navigation)
- Use Tailwind CSS utility classes, avoid custom CSS when possible
- Implement responsive design (mobile-first approach)

## Testing Standards

### Python Testing
```python
# Use pytest with async support
import pytest
import pytest_asyncio

@pytest.mark.asyncio
async def test_document_processing():
    processor = DocumentProcessor()
    result = await processor.process(mock_document)
    assert result.chunks is not None
    assert len(result.chunks) > 0

# Mock external dependencies
@pytest.fixture
def mock_llm():
    with patch('lib.agents.claim_detector.init_chat_model') as mock:
        mock.return_value.ainvoke.return_value = MockResponse()
        yield mock
```

### Frontend Testing
```tsx
// Use React Testing Library patterns
import { render, screen, fireEvent } from '@testing-library/react';

test('file upload handles drag and drop', async () => {
  const onUpload = jest.fn();
  render(<FileUpload onUpload={onUpload} />);
  
  const dropzone = screen.getByTestId('file-dropzone');
  fireEvent.drop(dropzone, { dataTransfer: { files: [mockFile] } });
  
  expect(onUpload).toHaveBeenCalledWith([mockFile]);
});
```

## Performance Guidelines

### Backend Performance
- Use async/await for all I/O operations
- Implement connection pooling for database operations
- Cache embeddings using LocalFileStore (as implemented)
- Use background tasks for long-running operations
- Implement proper database indexing

### Frontend Performance
- Use React.memo for expensive components
- Implement code splitting with dynamic imports
- Optimize images and assets
- Use proper key props in lists
- Avoid unnecessary re-renders with useCallback/useMemo

## Security Considerations

### Backend Security
- Validate all input data with Pydantic models
- Use environment variables for sensitive configuration
- Implement proper CORS settings
- Sanitize file uploads and validate file types
- Use parameterized queries (SQLModel handles this)

### Frontend Security
- Validate API responses
- Sanitize user input before display
- Use proper Content Security Policy headers
- Avoid inline scripts and styles

## Documentation Standards

- Use clear, descriptive commit messages
- Update README.md when adding new features
- Document environment variables in .env.example
- Keep API documentation up to date with FastAPI auto-docs
- Write migration scripts with clear descriptions

## Common Anti-patterns to Avoid

### Python Anti-patterns
- Don't use `import *`
- Avoid deeply nested callback functions
- Don't mix sync/async code patterns
- Avoid large functions (>20 lines)
- Don't use mutable default arguments
- Don't split logically cohesive code just to meet line limits
- Avoid creating tiny files with single functions that belong together

### Frontend Anti-patterns
- Don't mutate props directly
- Avoid using index as key in lists
- Don't use nested ternary operators
- Avoid large useEffect dependencies arrays
- Don't bypass TypeScript with `any` type
- Don't split cohesive components just to meet line limits
- Avoid over-fragmenting related component logic into separate files

## Development Workflow

1. **Feature Development**:
   - Create feature branch from main
   - Write tests first (TDD when possible)
   - Implement feature following these rules
   - Run linters and tests locally

2. **Code Review**:
   - Review for adherence to these rules
   - Check test coverage
   - Verify performance implications
   - Ensure security considerations

3. **Deployment**:
   - All tests must pass
   - Database migrations tested
   - Environment variables documented
   - Docker containers build successfully

Remember: These rules exist to maintain code quality and consistency. When in doubt, favor readability and maintainability over cleverness.
